# 实战经验：Gone 框架模块化改造中的 Go Work 反思

随着项目的不断扩大，代码库的膨胀，模块化开发变得越来越重要。在 Go 语言生态中，官方提供了 `go work` 命令来支持多模块开发。但在实际使用过程中，我发现这个工具并不像预期那样好用。本文将分享我在 gone 框架模块化改造过程中对 `go work` 的调研和使用体验。

## 背景介绍

最近我正在进行 gone 框架的模块化改造（[Gone框架模块化改造之路](https://blog.csdn.net/waitdeng/article/details/146452337)）。随着功能的不断增加，gone 框架变得越来越复杂，为了更好地维护代码和允许用户按需使用功能，我决定将框架拆分为多个模块。

在多模块开发场景下，我们需要一种能够同时处理多个本地模块的方案，于是 `go work` 进入了我的视野。按照官方的描述，`go work` 应该能够帮助我们管理多模块项目，使本地开发变得更加便捷。带着这样的期望，我开始了对 `go work` 的探索。

## go work 的基本使用场景

`go work` 是 Go 1.18 版本引入的功能，主要用于解决以下几个场景：

1. **本地多模块开发**：当你同时开发多个相互依赖的模块时，可以使用 `go work` 将它们组织在一起。
2. **模块替换**：无需在每个模块的 `go.mod` 文件中使用 `replace` 指令，可以在 `go.work` 文件中集中管理。
3. **避免发布替换**：`go.work` 文件通常不会提交到版本控制系统中，因此不会影响发布版本。

基本使用非常简单：

```bash
# 创建一个 go.work 文件
go work init

# 添加模块到工作区
go work use ./module1 ./module2

# 查看当前工作区配置
go work edit -json
```

一个典型的 `go.work` 文件内容如下：

```
go 1.18

use (
    ./module1
    ./module2
)

replace example.com/original => example.com/fork v1.2.3
```

看起来很美好，不是吗？但实际使用中，问题随之而来。

## go work 存在的问题

### 1. 命令兼容性问题：最致命的局限

**最主要的问题在于**：大多数处理模块的 `go` 子命令确实能在工作区环境中运行，但 `go mod init`、`go mod why`、`go mod edit`、`go mod tidy`、`go mod vendor` 和 `go get` 这些核心命令**始终只能操作单个主模块**。

参考：https://github.com/golang/go/issues/50750 和 https://go.dev/ref/mod#workspaces


这个局限性直接导致了在使用 `go work` 的多模块项目中，我们仍然需要频繁地切换目录来执行这些命令，这与 `go work` 简化工作流程的初衷背道而驰。例如：

- 无法一次性对工作区中的所有模块执行 `go mod tidy`
- 无法在工作区级别统一管理所有模块的依赖
- 需要在各个模块目录间来回切换执行模块管理命令

这使得 `go work` 更像是一个编译时的辅助工具，而非完整的多模块开发解决方案。

### 2. 版本管理混乱

使用 `go work` 后，各个模块的 `go.mod` 文件和工作区的 `go.work` 文件可能会同时包含依赖管理信息，这在一定程度上导致了版本管理的混乱。特别是当某个依赖在 `go.work` 中指定了一个版本，而在某个模块的 `go.mod` 中指定了另一个版本时，会导致构建结果的不确定性。

### 3. CI/CD 集成问题

由于 `go.work` 文件通常不会提交到版本控制系统中，这导致本地开发环境和 CI/CD 环境存在差异。在 CI/CD 中，我们需要额外的步骤来模拟 `go work` 的行为，或者为 CI/CD 专门维护一份 `go.work` 文件，这增加了维护成本。

## 实际案例：gone 框架的模块化挑战

在 gone 框架的模块化过程中，我们面临以下挑战：

1. 核心模块需要被多个功能模块引用，但某些功能模块之间也存在依赖关系。
2. 不同模块的开发进度不同，版本更新频率也不一致。
3. 需要确保用户可以方便地选择所需的模块，而不必引入整个框架。

最初，我们尝试使用 `go work` 来管理这些模块，但很快发现上述问题影响了开发效率。特别是在多人协作开发时，由于无法在工作区级别执行 `go mod tidy` 和 `go get`，团队成员经常需要手动同步各个模块的依赖，这极大地降低了开发效率。

最终，我们放弃了使用 `go work`，而是回归到使用 `go mod` 的 `replace` 指令来管理模块间的依赖关系。虽然这意味着我们需要在每个模块的 `go.mod` 文件中添加 `replace` 指令，但这种方式提供了更一致、更可靠的开发体验。

## 结论：有用，但很鸡肋

经过一段时间的使用和调研，我得出的结论是：`go work` 确实有用，但很鸡肋。

它解决了一些基本的多模块开发问题，特别是在编译和构建方面，但在依赖管理和工作流程简化方面却远远不够。最致命的是那些核心的模块管理命令（`go mod tidy`、`go get` 等）无法在工作区级别操作，这使得 `go work` 的实用性大打折扣。


总之，`go work` 就像是一道鸡肋 —— 不是特别好吃，但也不是完全没用。在使用它之前，我们应该充分了解它的局限性，并根据项目的实际需求决定是否采用它。作为 Go 开发者，我们期待官方在未来能够增强 `go work` 的功能，使其成为一个更全面的多模块开发解决方案。

---

你有使用 `go work` 的经验吗？欢迎在评论区分享你的看法和经验！