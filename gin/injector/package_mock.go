// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go
//
// Generated by this command:
//
//	mockgen -source=interface.go -destination=package_mock.go -package=injector
//

// Package injector is a generated GoMock package.
package injector

import (
	"github.com/gone-io/gone/v2"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockNameParser is a mock of NameParser interface.
type MockNameParser[P any] struct {
	gone.Flag
	ctrl     *gomock.Controller
	recorder *MockNameParserMockRecorder[P]
	isgomock struct{}
}

// MockNameParserMockRecorder is the mock recorder for MockNameParser.
type MockNameParserMockRecorder[P any] struct {
	mock *MockNameParser[P]
}

// NewMockNameParser creates a new mock instance.
func NewMockNameParser[P any](ctrl *gomock.Controller) *MockNameParser[P] {
	mock := &MockNameParser[P]{ctrl: ctrl}
	mock.recorder = &MockNameParserMockRecorder[P]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockNameParser[P]) EXPECT() *MockNameParserMockRecorder[P] {
	return m.recorder
}

// BuildParser mocks base method.
func (m *MockNameParser[P]) BuildParser(keyMap map[string]string, field reflect.StructField) (func(P) (reflect.Value, error), error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildParser", keyMap, field)
	ret0, _ := ret[0].(func(P) (reflect.Value, error))
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BuildParser indicates an expected call of BuildParser.
func (mr *MockNameParserMockRecorder[P]) BuildParser(keyMap, field any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildParser", reflect.TypeOf((*MockNameParser[P])(nil).BuildParser), keyMap, field)
}

// Name mocks base method.
func (m *MockNameParser[P]) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockNameParserMockRecorder[P]) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockNameParser[P])(nil).Name))
}

// MockTypeParser is a mock of TypeParser interface.
type MockTypeParser[P any] struct {
	gone.Flag
	ctrl     *gomock.Controller
	recorder *MockTypeParserMockRecorder[P]
	isgomock struct{}
}

// MockTypeParserMockRecorder is the mock recorder for MockTypeParser.
type MockTypeParserMockRecorder[P any] struct {
	mock *MockTypeParser[P]
}

// NewMockTypeParser creates a new mock instance.
func NewMockTypeParser[P any](ctrl *gomock.Controller) *MockTypeParser[P] {
	mock := &MockTypeParser[P]{ctrl: ctrl}
	mock.recorder = &MockTypeParserMockRecorder[P]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTypeParser[P]) EXPECT() *MockTypeParserMockRecorder[P] {
	return m.recorder
}

// Parse mocks base method.
func (m *MockTypeParser[P]) Parse(context P) (reflect.Value, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Parse", context)
	ret0, _ := ret[0].(reflect.Value)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Parse indicates an expected call of Parse.
func (mr *MockTypeParserMockRecorder[P]) Parse(context any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Parse", reflect.TypeOf((*MockTypeParser[P])(nil).Parse), context)
}

// Type mocks base method.
func (m *MockTypeParser[P]) Type() reflect.Type {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(reflect.Type)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockTypeParserMockRecorder[P]) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockTypeParser[P])(nil).Type))
}

// MockBindExecutor is a mock of BindExecutor interface.
type MockBindExecutor[P any] struct {
	gone.Flag
	ctrl     *gomock.Controller
	recorder *MockBindExecutorMockRecorder[P]
	isgomock struct{}
}

// MockBindExecutorMockRecorder is the mock recorder for MockBindExecutor.
type MockBindExecutorMockRecorder[P any] struct {
	mock *MockBindExecutor[P]
}

// NewMockBindExecutor creates a new mock instance.
func NewMockBindExecutor[P any](ctrl *gomock.Controller) *MockBindExecutor[P] {
	mock := &MockBindExecutor[P]{ctrl: ctrl}
	mock.recorder = &MockBindExecutorMockRecorder[P]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBindExecutor[P]) EXPECT() *MockBindExecutorMockRecorder[P] {
	return m.recorder
}

// FindFieldSetter mocks base method.
func (m *MockBindExecutor[P]) FindFieldSetter(conf string, field reflect.StructField) (FieldSetter[P], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindFieldSetter", conf, field)
	ret0, _ := ret[0].(FieldSetter[P])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindFieldSetter indicates an expected call of FindFieldSetter.
func (mr *MockBindExecutorMockRecorder[P]) FindFieldSetter(conf, field any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindFieldSetter", reflect.TypeOf((*MockBindExecutor[P])(nil).FindFieldSetter), conf, field)
}

// InjectedByType mocks base method.
func (m *MockBindExecutor[P]) InjectedByType(pt reflect.Type) BindFunc[P] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InjectedByType", pt)
	ret0, _ := ret[0].(BindFunc[P])
	return ret0
}

// InjectedByType indicates an expected call of InjectedByType.
func (mr *MockBindExecutorMockRecorder[P]) InjectedByType(pt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InjectedByType", reflect.TypeOf((*MockBindExecutor[P])(nil).InjectedByType), pt)
}

// MockDelayBindInjector is a mock of DelayBindInjector interface.
type MockDelayBindInjector[P any] struct {
	ctrl     *gomock.Controller
	recorder *MockDelayBindInjectorMockRecorder[P]
	isgomock struct{}
}

// MockDelayBindInjectorMockRecorder is the mock recorder for MockDelayBindInjector.
type MockDelayBindInjectorMockRecorder[P any] struct {
	mock *MockDelayBindInjector[P]
}

// NewMockDelayBindInjector creates a new mock instance.
func NewMockDelayBindInjector[P any](ctrl *gomock.Controller) *MockDelayBindInjector[P] {
	mock := &MockDelayBindInjector[P]{ctrl: ctrl}
	mock.recorder = &MockDelayBindInjectorMockRecorder[P]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDelayBindInjector[P]) EXPECT() *MockDelayBindInjectorMockRecorder[P] {
	return m.recorder
}

// GonerName mocks base method.
func (m *MockDelayBindInjector[P]) GonerName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GonerName")
	ret0, _ := ret[0].(string)
	return ret0
}

// GonerName indicates an expected call of GonerName.
func (mr *MockDelayBindInjectorMockRecorder[P]) GonerName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GonerName", reflect.TypeOf((*MockDelayBindInjector[P])(nil).GonerName))
}

// Inject mocks base method.
func (m *MockDelayBindInjector[P]) Inject(tagConf string, field reflect.StructField, fieldValue reflect.Value) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inject", tagConf, field, fieldValue)
	ret0, _ := ret[0].(error)
	return ret0
}

// Inject indicates an expected call of Inject.
func (mr *MockDelayBindInjectorMockRecorder[P]) Inject(tagConf, field, fieldValue any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inject", reflect.TypeOf((*MockDelayBindInjector[P])(nil).Inject), tagConf, field, fieldValue)
}

// Prepare mocks base method.
func (m *MockDelayBindInjector[P]) Prepare(x any) (CompiledFunc[P], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prepare", x)
	ret0, _ := ret[0].(CompiledFunc[P])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Prepare indicates an expected call of Prepare.
func (mr *MockDelayBindInjectorMockRecorder[P]) Prepare(x any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prepare", reflect.TypeOf((*MockDelayBindInjector[P])(nil).Prepare), x)
}

// goneFlag mocks base method.
func (m *MockDelayBindInjector[P]) goneFlag() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "goneFlag")
}

// goneFlag indicates an expected call of goneFlag.
func (mr *MockDelayBindInjectorMockRecorder[P]) goneFlag() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "goneFlag", reflect.TypeOf((*MockDelayBindInjector[P])(nil).goneFlag))
}
